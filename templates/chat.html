{% extends "base.html" %}

{% block header %}Chat with Documents{% endblock %}

{% block content %}
<div x-data="chatApp()" class="flex h-full -m-8">

    <!-- Conversation Sidebar -->
    <div class="w-72 bg-white border-r border-gray-200 flex flex-col flex-shrink-0">
        <div class="p-4 border-b border-gray-100">
            <button @click="newConversation()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 rounded-lg transition-colors flex items-center justify-center gap-2">
                <i class="fa-solid fa-plus"></i> New Chat
            </button>
        </div>

        <div class="flex-1 overflow-y-auto p-2 space-y-1">
            {% for conv in conversations %}
            <button class="w-full text-left px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors text-sm truncate text-gray-700"
                    @click="loadConversation('{{ conv.id }}', '{{ conv.title | default('Untitled', true) }}')">
                <i class="fa-regular fa-comment mr-2 text-gray-400"></i>
                {{ conv.title or 'Untitled' }}
            </button>
            {% endfor %}
            {% if not conversations %}
            <p class="text-center text-gray-400 text-sm py-4">No conversations yet</p>
            {% endif %}
        </div>
    </div>

    <!-- Chat Area -->
    <div class="flex-1 flex flex-col min-w-0">
        <!-- Messages -->
        <div class="flex-1 overflow-y-auto p-6 space-y-4" id="messagesContainer">
            <!-- Empty state -->
            <div x-show="messages.length === 0" class="flex flex-col items-center justify-center h-full text-gray-400">
                <i class="fa-solid fa-comments text-5xl mb-4"></i>
                <h3 class="text-xl font-semibold text-gray-600 mb-2">Ask your documents anything</h3>
                <p class="text-sm">Your questions will be answered using RAG with source citations.</p>
            </div>

            <template x-for="msg in messages" :key="msg.id">
                <div :class="msg.role === 'user' ? 'flex justify-end' : 'flex justify-start'">
                    <div :class="msg.role === 'user' ? 'bg-blue-600 text-white rounded-2xl rounded-br-md max-w-2xl' : 'bg-white border border-gray-200 rounded-2xl rounded-bl-md max-w-3xl shadow-sm'"
                         class="px-5 py-3">
                        <!-- User message -->
                        <p x-show="msg.role === 'user'" x-text="msg.content" class="whitespace-pre-wrap"></p>

                        <!-- Assistant message -->
                        <div x-show="msg.role === 'assistant'">
                            <div class="prose prose-sm max-w-none text-gray-800" x-html="renderMarkdown(msg.content)"></div>

                            <!-- Sources -->
                            <div x-show="msg.sources && msg.sources.length > 0" class="mt-3 pt-3 border-t border-gray-100">
                                <p class="text-xs font-medium text-gray-500 mb-1">Sources:</p>
                                <div class="flex flex-wrap gap-1">
                                    <template x-for="(src, srcIndex) in (msg.sources || [])" :key="(src.chunk_id || src.document_id || 'src') + '-' + srcIndex">
                                        <span class="text-xs bg-blue-50 text-blue-600 px-2 py-0.5 rounded-full" x-text="src.document_name + (src.page_number ? ', p' + src.page_number : '')"></span>
                                    </template>
                                </div>
                            </div>

                            <!-- Confidence -->
                            <div x-show="msg.confidence" class="mt-2">
                                <span class="text-xs px-2 py-0.5 rounded-full"
                                      :class="msg.confidence === 'high' ? 'bg-green-100 text-green-700' : msg.confidence === 'medium' ? 'bg-yellow-100 text-yellow-700' : 'bg-red-100 text-red-700'"
                                      x-text="'Confidence: ' + msg.confidence"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </template>

            <!-- Streaming indicator -->
            <div x-show="isStreaming" class="flex justify-start">
                <div class="bg-white border border-gray-200 rounded-2xl rounded-bl-md px-5 py-3 shadow-sm">
                    <div class="flex items-center gap-2 text-gray-500">
                        <i class="fa-solid fa-circle-notch fa-spin"></i>
                        <span class="text-sm" x-text="streamStatus"></span>
                    </div>
                    <div x-show="streamContent" class="mt-2 prose prose-sm max-w-none text-gray-800" x-html="renderMarkdown(streamContent)"></div>
                </div>
            </div>
        </div>

        <!-- Input -->
        <div class="border-t border-gray-200 bg-white p-4">
            <form @submit.prevent="sendMessage" class="flex gap-3 max-w-4xl mx-auto">
                <input type="text" x-model="inputText" placeholder="Ask a question about your documents..."
                       class="flex-1 px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all"
                       :disabled="isStreaming">
                <button type="submit" :disabled="isStreaming || !inputText.trim()"
                        class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-xl transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2">
                    <i class="fa-solid fa-paper-plane"></i>
                    Send
                </button>
            </form>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
function chatApp() {
    return {
        messages: [],
        inputText: '',
        conversationId: null,
        isStreaming: false,
        streamContent: '',
        streamStatus: 'Searching documents...',
        
        renderMarkdown(content) {
            const markdown = marked.parse(content || '');
            return DOMPurify.sanitize(markdown);
        },

        newConversation() {
            this.messages = [];
            this.conversationId = null;
        },

        async loadConversation(id, title) {
            this.conversationId = id;
            this.messages = [];

            try {
                const resp = await fetch(`/api/conversations/${id}/messages`);
                if (!resp.ok) {
                    throw new Error('Failed to load conversation history');
                }

                const history = await resp.json();
                this.messages = (history || []).map((msg, index) => ({
                    id: msg.id || `${Date.now()}-${index}`,
                    role: msg.role,
                    content: msg.content || '',
                    sources: msg.sources || [],
                    confidence: msg.confidence || null
                }));
                this.scrollToBottom();
            } catch (e) {
                console.error(e);
            }
        },

        async sendMessage() {
            const query = this.inputText.trim();
            if (!query) return;

            // Add user message
            this.messages.push({
                id: Date.now(),
                role: 'user',
                content: query
            });
            this.inputText = '';
            this.isStreaming = true;
            this.streamContent = '';
            this.streamStatus = 'Searching documents...';

            this.scrollToBottom();

            try {
                const resp = await fetch('/api/chat/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: query,
                        conversation_id: this.conversationId
                    })
                });

                if (!resp.ok || !resp.body) {
                    throw new Error('Failed to start stream');
                }

                const reader = resp.body.getReader();
                const decoder = new TextDecoder();
                let sources = [];
                let confidence = null;
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const events = buffer.split('\n\n');
                    buffer = events.pop() || '';

                    for (const eventText of events) {
                        const line = eventText.trim();
                        if (!line.startsWith('data: ')) continue;
                        try {
                            const data = JSON.parse(line.substring(6));

                            if (data.type === 'status') {
                                this.streamStatus = data.content;
                            } else if (data.type === 'sources') {
                                sources = data.content;
                            } else if (data.type === 'token') {
                                this.streamContent += data.content;
                                this.scrollToBottom();
                            } else if (data.type === 'done') {
                                this.conversationId = data.content.conversation_id;
                                confidence = data.content.confidence || confidence;
                            } else if (data.type === 'error') {
                                this.streamContent = 'Error: ' + data.content;
                            }
                        } catch (e) { /* skip malformed lines */ }
                    }
                }

                const pending = buffer.trim();
                if (pending.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(pending.substring(6));
                        if (data.type === 'done') {
                            this.conversationId = data.content.conversation_id;
                            confidence = data.content.confidence || confidence;
                        } else if (data.type === 'error') {
                            this.streamContent = 'Error: ' + data.content;
                        }
                    } catch (e) { /* skip malformed trailing event */ }
                }

                // Add assistant message
                this.messages.push({
                    id: Date.now(),
                    role: 'assistant',
                    content: this.streamContent,
                    sources: sources,
                    confidence: confidence
                });

            } catch (e) {
                this.messages.push({
                    id: Date.now(),
                    role: 'assistant',
                    content: 'Error connecting to backend: ' + e.message,
                    sources: [],
                    confidence: 'low'
                });
            }

            this.isStreaming = false;
            this.streamContent = '';
            this.scrollToBottom();
        },

        scrollToBottom() {
            this.$nextTick(() => {
                const container = document.getElementById('messagesContainer');
                if (container) container.scrollTop = container.scrollHeight;
            });
        }
    }
}
</script>
{% endblock %}
